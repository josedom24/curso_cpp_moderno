Perfecto, aquí tienes el apartado **Punteros inteligentes** para tu curso de C++ moderno:

---

## Gestión de recursos y punteros

### Punteros inteligentes

En C++, el manejo manual de memoria con punteros crudos (`raw pointers`) puede conducir a errores comunes como fugas de memoria, doble liberación y punteros colgantes. Para mitigar estos riesgos, el estándar moderno de C++ introduce los **punteros inteligentes** (`smart pointers`), que encapsulan punteros crudos y gestionan automáticamente la vida útil de los objetos a los que apuntan.

#### ¿Qué son los punteros inteligentes?

Los punteros inteligentes son clases plantilla que actúan como contenedores para punteros crudos y proporcionan una gestión automática del recurso, liberando memoria cuando ya no es necesaria. Esto se consigue mediante la sobrecarga de operadores y la implementación de técnicas como el conteo de referencias.

Los punteros inteligentes más comunes en la biblioteca estándar de C++ (`<memory>`) son:

* `std::unique_ptr`
* `std::shared_ptr`
* `std::weak_ptr`

---

#### 1. `std::unique_ptr`

* Representa la propiedad exclusiva de un recurso.
* Solo puede haber un único `unique_ptr` que posea el objeto apuntado.
* No se puede copiar, pero sí mover (transferencia de propiedad).
* Al salir de su ámbito, libera automáticamente el recurso que posee.

Ejemplo:

```cpp
#include <memory>
#include <iostream>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    std::cout << *ptr << std::endl;

    // Transferencia de propiedad mediante move
    std::unique_ptr<int> ptr2 = std::move(ptr);
    if (!ptr) {
        std::cout << "ptr es ahora nulo después de mover." << std::endl;
    }

    // ptr2 libera automáticamente la memoria al salir del ámbito
    return 0;
}
```

Ventajas:

* Evita fugas de memoria.
* Garantiza la propiedad única, útil para recursos no compartidos.

---

#### 2. `std::shared_ptr`

* Permite la propiedad compartida del recurso mediante **conteo de referencias**.
* Múltiples `shared_ptr` pueden apuntar al mismo objeto.
* El recurso se libera automáticamente cuando el último `shared_ptr` que lo posee es destruido o reasignado.

Ejemplo:

```cpp
#include <memory>
#include <iostream>

int main() {
    std::shared_ptr<int> sp1 = std::make_shared<int>(100);
    {
        std::shared_ptr<int> sp2 = sp1; // comparte propiedad
        std::cout << "Uso del recurso: " << *sp2 << std::endl;
        std::cout << "Conteo de referencias: " << sp1.use_count() << std::endl;
    }
    std::cout << "Conteo de referencias tras salir del bloque: " << sp1.use_count() << std::endl;
    // El recurso se libera cuando sp1 sale del ámbito

    return 0;
}
```

Precauciones:

* Puede provocar ciclos de referencias (deadlocks) si no se usan correctamente, causando fugas de memoria.

---

#### 3. `std::weak_ptr`

* Complementa a `shared_ptr` para romper ciclos de referencias.
* No posee ni controla la vida útil del recurso, sino que observa un objeto gestionado por `shared_ptr`.
* Permite verificar si el recurso aún existe antes de usarlo mediante el método `.lock()`.

Ejemplo:

```cpp
#include <memory>
#include <iostream>

int main() {
    std::shared_ptr<int> sp = std::make_shared<int>(200);
    std::weak_ptr<int> wp = sp;  // wp no incrementa el conteo de referencias

    if (auto spt = wp.lock()) { // Se obtiene un shared_ptr temporal si el recurso existe
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ha sido liberado." << std::endl;
    }

    return 0;
}
```

---

#### Beneficios generales de los punteros inteligentes

* **Gestión automática y segura de la memoria:** liberan recursos automáticamente evitando fugas.
* **Evitan errores comunes:** como doble liberación o acceso a memoria liberada.
* **Integración con excepciones:** garantizan la liberación del recurso incluso si se lanza una excepción.
* **Mayor claridad y expresividad:** reflejan claramente la propiedad y duración del recurso.

---

### Conclusión

Los punteros inteligentes son un pilar esencial para la gestión segura y eficiente de recursos en C++ moderno. Permiten abstraer la complejidad del manejo manual de memoria y facilitan el desarrollo de aplicaciones robustas, manteniendo la eficiencia y control que caracterizan al lenguaje.

En el siguiente apartado, se profundizará en el patrón RAII (Resource Acquisition Is Initialization), que se apoya fuertemente en punteros inteligentes para la gestión automática de recursos.

---

¿Quieres que continúe con el apartado **RAII (Resource Acquisition Is Initialization)**?
